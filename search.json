[{"title":"kubernets安装过程解决墙外不通的问题","url":"%2F2019%2F12%2F05%2Fkubernets%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E8%A7%A3%E5%86%B3%E5%A2%99%E5%A4%96%E4%B8%8D%E9%80%9A%E7%9A%84%E9%97%AE%E9%A2%98%2F","content":"> 必须条件\n* 一台HK 主机\n* ss服务\n> 步骤\n解决docker pull镜像问题就可以了，pull回来配置用自己的仓库，具体配置参考上上文\nshadowsocks是socks5的代理类型， 代理http/https流量还需要privoxy ![安装参考](https://blog.whsir.com/post-2711.html)\nlinux\n参考上面文章安装sslocal,provixy,在provixy中设置好服务ip和端口供下面docker设置\n\n（1）创建以下目录：/etc/systemd/system/docker.service.d\n（2）在上述目录下创建http-proxy.conf文件，内容如下：\n\t[Service] \n\tEnvironment=\"HTTP_PROXY=http://ip:port/\" \"HTTPS_PROXY=http://ip:port/\" \"NO_PROXY=localhost,127.0.0.1,×.×.×.×\" \n\t//no-proxy配置项通常用于配置我们自己搭建的私有docker仓库\t\n（3）刷新配置，重启docker服务：\n\tsudo systemctl daemon-reload\n\tsudo service docker restart\n\tsystemctl show --property=Environment docker  //如果配置成功，执行该命令将会看到配置的代理信息\n\nmac\n![ss client设置http代理](https://spark-1300032833.cos.ap-guangzhou.myqcloud.com/blog/2019-12-06-qaa531.png)\n![docker设置](https://spark-1300032833.cos.ap-guangzhou.myqcloud.com/blog/2019-12-06-kOALgc.png)\n\n\n","tags":["kubernets,shadowsocks,docker"]},{"title":"kubernets从自建register部署镜像","url":"%2F2019%2F12%2F04%2Fkubernets%E4%BB%8E%E8%87%AA%E5%BB%BAregister%E9%83%A8%E7%BD%B2%E9%95%9C%E5%83%8F%2F","content":"# harbor\n## 安装\n~~~\n1、安装docker，docker-compose\n2、安装harbor\nwget -P /usr/loca/src/     https://storage.googleapis.com/harbor-releases/release-1.7.0/harbor-online-installer-v1.7.5.tgz\ncd /usr/local/src/\ntar zxf harbor-online-installer-v1.2.0.tgz  -C /usr/local/\ncd /usr/local/harbor/\n3、配置hostname,email,db...\nvim /usr/local/harbor/harbor.cfg\n4、执行\n./install.sh\n~~~\n## 配置https\n证书申请过程省略\n~~~\nvi /usr/local/harbor/harbor.cfg\nui_url_protocol = https\nssl_cert = /root/.acme.sh/hub.mlink.tv/fullchain.cer\nssl_cert_key = /root/.acme.sh/hub.mlink.tv/hub.mlink.tv.key\n~~~\n\n# kubernets\n~~~\ndocker login https:hub.mlink.tv然后docker pull...这种方式在kubernets中不能成功\n正确的姿势\na、\nkubectl create secret docker-registry registry-secret --docker-server=registry.cn-shenzhen.aliyuncs.com --docker-username=user-test --docker-password=xxxxxx --docker-email=xxx@xxx.com -n default\n--docker-server: 仓库地址\n--docker-username: 仓库登陆账号\n--docker-password: 仓库登陆密码\n--docker-email: 邮件地址(选填)\n-n 命名空间\n\nb、在deployment.yml中添加imagePullSecrets，name的值为上面设置的secret name\nspec:\n      serviceAccountName: test\n      imagePullSecrets:\n      - name: registry-secret\n      containers:\n      - name: test\n        image: registry.cn-shenzhen.aliyuncs.com/koza/test:latest\n~~~","tags":["harbor,kubernets"]},{"title":"利用ffmpeg拉流转推流任务持久化处理","url":"%2F2019%2F11%2F28%2F%E5%88%A9%E7%94%A8ffmpeg%E6%8B%89%E6%B5%81%E8%BD%AC%E6%8E%A8%E6%B5%81%E4%BB%BB%E5%8A%A1%E6%8C%81%E4%B9%85%E5%8C%96%E5%A4%84%E7%90%86%2F","content":"## supervisor\n\n一、安装supvisor\npip install supervisor\n\nSupervisor 相当强大，提供了很丰富的功能，不过我们可能只需要用到其中一小部分。安装完成之后，可以编写配置文件，来满足自己的需求。为了方便，我们把配置分成两部分：\n1、supervisord（supervisor 是一个 C/S 模型的程序，这是 server 端，对应的有 client 端：supervisorctl）\n2、应用程序配置（即我们要管理的程序）。\n\n二、输出配置文件\n首先来看 supervisord 的配置文件。安装完 supervisor 之后，可以运行echo_supervisord_conf 命令输出默认的配置项，也可以重定向到一个配置文件里：\necho_supervisord_conf > /etc/supervisord.conf\n \n/etc/supervisord.conf配置说明：\n\n[unix_http_server]\nfile=/tmp/supervisor.sock   ; UNIX socket 文件，supervisorctl 会使用\n;chmod=0700                 ; socket 文件的 mode，默认是 0700\n;chown=nobody:nogroup       ; socket 文件的 owner，格式： uid:gid\n\n;[inet_http_server]         ; HTTP 服务器，提供 web 管理界面\n;port=127.0.0.1:9001        ; Web 管理后台运行的 IP 和端口，如果开放到公网，需要注意安全性\n;username=user              ; 登录管理后台的用户名\n;password=123               ; 登录管理后台的密码\n\n[supervisord]\nlogfile=/tmp/supervisord.log ; 日志文件，默认是 $CWD/supervisord.log\nlogfile_maxbytes=50MB        ; 日志文件大小，超出会 rotate，默认 50MB\nlogfile_backups=10           ; 日志文件保留备份数量默认 10\nloglevel=info                ; 日志级别，默认 info，其它: debug,warn,trace\npidfile=/tmp/supervisord.pid ; pid 文件\nnodaemon=false               ; 是否在前台启动，默认是 false，即以 daemon 的方式启动\nminfds=1024                  ; 可以打开的文件描述符的最小值，默认 1024\nminprocs=200                 ; 可以打开的进程数的最小值，默认 200\n\n; the below section must remain in the config file for RPC\n; (supervisorctl/web interface) to work, additional interfaces may be\n; added by defining them in separate rpcinterface: sections\n[rpcinterface:supervisor]\nsupervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface\n\n[supervisorctl]\nserverurl=unix:///tmp/supervisor.sock ; 通过 UNIX socket 连接 supervisord，路径与 unix_http_server 部分的 file 一致\n;serverurl=http://127.0.0.1:9001 ; 通过 HTTP 的方式连接 supervisord\n\n; 包含其他的配置文件\n[include]\nfiles = relative/directory/*.ini    ; 可以是 *.conf 或 *.ini\n\n三、为了方便自定义配置管理，\n创建文件夹/etc/supervisor\n然后修改/etc/supervisord.conf\n[include]\nfiles = /etc/supervisor/*.conf\n\n四、启动supervisor\nsupervisord -c /etc/supervisord.conf\n\n五、现在编写一份配置文件来管理这个进程放在/etc/supervisor\nvi gogs.conf\n[program:gogs]\ndirectory = /usr/local/gopeo/.....; 程序的启动目录\ncommand = gunicorn -c gunicorn.py wsgi:app  ; 启动命令，可以看出与手动在命令行启动的命令是一样的\nautostart = true     ; 在 supervisord 启动的时候也自动启动\nstartsecs = 5        ; 启动 5 秒后没有异常退出，就当作已经正常启动了\nautorestart = true   ; 程序异常退出后自动重启\nstartretries = 3     ; 启动失败自动重试次数，默认是 3\nuser = leon          ; 用哪个用户启动\nredirect_stderr = true  ; 把 stderr 重定向到 stdout，默认 false\nstdout_logfile_maxbytes = 20MB  ; stdout 日志文件大小，默认 50MB\nstdout_logfile_backups = 20     ; stdout 日志文件备份数\n; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）\nstdout_logfile = /data/logs/usercenter_stdout.log\n \n; 可以通过 environment 来添加需要的环境变量，一种常见的用法是修改 PYTHONPATH\n; environment=PYTHONPATH=$PYTHONPATH:/path/to/somewhere\n六、启动Supervisorctl \nsupervisorctl -c /etc/supervisord.conf\n\n其他命令\nsupervisorctl status\nsupervisorctl stop gogs\nsupervisorctl start gogs\nsupervisorctl restart gogs\nsupervisorctl reread\nsupervisorctl update\n\n七、可以修改supervisord.conf中的配置通过web界面管理\n[inet_http_server]         ; HTTP 服务器，提供 web 管理界面\nport=0.0.0.0:9001        ; Web 管理后台运行的 IP 和端口，如果开放到公网，需要注意安全性\nusername=user              ; 登录管理后台的用户名\npassword=123               ; 登录管理后台的密码\n\n## ffmpeg\n\nwget https://ffmpeg.org/releases/ffmpeg-3.4.2.tar.bz2\nwget http://www.tortall.net/projects/yasm/releases/yasm-1.3.0.tar.gz\ntar zxvf yasm-1.3.0.tar.gz\ncd yasm-1.3.0/\n./configure\n make\n make install\n\nyum install bzip2\nbzip2 -d ffmpeg-3.4.2.tar.bz2\ntar xvf ffmpeg-3.4.2.tar\ncd ffmpeg-3.4.2/\n./configure --enable-static --disable-shared --disable-yasm --enable-gpl --disable-libx264 --disable-librtmp --extra-cflags=-I/usr/local/include --extra-ldflags=-L/usr/local/lib --prefix=/usr/local\n\n make\n make install\n\nvi /etc/ld.so.conf\n添加\n /usr/local/ffmpeg/lib\n /usr/local/lib\n\nldconfig\n\ncd ffmpeg-3.4.2/\n\nffmpeg -i http://wo1.live.cnlive.com:1935/cdn/ffyl1/playlist.m3u8 -bsf:a aac_adtstoasc -acodec copy -vcodec copy -f flv rtmp://apush.mlink.tv/mlzx/ffyl\n\n ffmpeg -i 要拉取的URL -acodec copy -vcodec copy -f flv 腾讯云／阿里云／金山云／七牛云rtmp推流地址","tags":["ffmpeg supervisord"]},{"title":"nginx日志分析awk","url":"%2F2019%2F11%2F11%2Fnginx%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90awk%2F","content":"切割日志\n\n查找7月17日访问log导出到17.log文件中：\n~~~\ncat gelin_web_access.log | egrep \"17/Jul/2017\" | sed  -n '/00:00:00/,/23:59:59/p' > /tmp/17.log\n~~~\n查看访问量前10的IP\n~~~\nawk '{print $1}' 17.log | sort | uniq -c | sort -nr | head -n 10 \n~~~\n查看访问前10的URL\n~~~\nawk '{print $11}' gelin_web_access.log | sort | uniq -c | sort -nr | head -n 10\n~~~\n查询访问最频繁的URL\n~~~\nawk '{print $7}' gelin_web_access.log | sort | uniq -c | sort -n -k 1 -r | more\n~~~\n查询访问最频繁的IP\n~~~\nawk '{print $1}' gelin_web_access.log | sort | uniq -c | sort -n -k 1 -r | more\n~~~\n根据访问IP统计UV\n~~~\nawk '{print $1}' gelin_web_access.log | sort | uniq -c | wc -l\n~~~\n统计访问URL统计PV\n~~~\nawk '{print $7}' gelin_web_access.log | wc -l\n~~~\n根据时间段统计查看日志\n~~~\ncat gelin_web_access.log | sed -n '/17\\/Jul\\/2017:12/,/17\\/Jul\\/2017:13/p' | more\n~~~","tags":["nginx awk"]},{"title":"深度工作力","url":"%2F2019%2F11%2F08%2F%E6%B7%B1%E5%BA%A6%E5%B7%A5%E4%BD%9C%E5%8A%9B%2F","content":"# 深度工作力\n## 背景\n一个人对生活的满意度在于自发性的去做具有挑战性的事情\n## 划重点\n* 不要等时间找你，要自己找时间\n    \n    需要完整的时间段【time block】，可以专心投入，避免注意力残留\n* 清晰上下班界限\n\n    如果下班有未完之事，就下班前写下列出来，并计划明天如何做。\n*  追踪成长的进步，奖励自己\n","tags":["工作"]},{"title":"算法训练营day2","url":"%2F2019%2F11%2F08%2F%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5day2%2F","content":"## 训练环境：\nvscode + leetcode\n## 快捷键\noption + delete 删除整个单词\n## 编码风格\n* 大括号前，运算符前留空格\n* if后留空格\n## 自顶向下编程\n* 主干逻辑，忽略细节\n\n","tags":["算法"]},{"title":"算法训练营day1","url":"%2F2019%2F11%2F08%2F%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5day1%2F","content":"\n精通一个领域三步走\n# chunk it up切碎知识点\n\n## 数据结构\n### 一维数据结构\n    基础：数组array、链表linked list\n    高级：栈stack，队列queue，双端队列deque，集合set，映射map\n### 二维数据结构\n    基础：树tree、图graph\n    高级：二叉搜索数，红黑树，AVL，堆heap 等等\n### 特殊数据结构\n    位运算，布隆过滤器\n    LRU cache\n\n## 算法\n### 基础\n* if else\n* for\n* 递归 recursion\n找重复单元\n### 高级\n搜索：depth first search 深度优先搜索，Breadth first search，etc\n动态规划：Dynamic Programming\n二分查找 binary search\n贪心算法 greedy\n数学math，几何geometry操作\n\n# deliberate practicing 刻意练习\n## 五遍刷题法\n### 第一遍\n* 读题5-10分钟，尽可能多想解法，想不出来不纠结，下一步\n* 看解法理解\n* 默写出来\n### 第二遍\n* 空白文件自己写出解法\n* leetcode上提交跑代码\n* 多尝试几种解法，看看时间空间复杂度\n### 第三遍\n* 过一天之后重刷\n\n### 第四遍\n* 过一周后重刷\n\n### 第五遍\n* 面试前一周恢复训练\n\n> 核心\n* 重复多次练习\n* 不舒服就对了\n## 切题四件套\n* clarification 多读几遍题目\n* possible solutions 尽可能想多种可能解法\n* coding 编码\n* test case 测试用例\n\n# feedback 反馈\n* 主动反馈\n* 被动反馈\n\n","tags":["算法"]},{"title":"费曼学习法","url":"%2F2019%2F11%2F08%2F%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95%2F","content":"# 费曼学习法\n## 背景\n诺奖得主-费曼“不断挑战自己本身了解的事情”\n## 四个步骤\n* 学习新东西，简单的语言解释给不专业的人听\n* 找出别人听不懂的地方和自己无法简单解释的概念\n* 回到学习资源，重新找寻上一步的问题\n* 重复以上3步，直到完全熟念相关的课题为止\n\n## 两个重点\n* 简单\n\n    向小孩子解释并能使之听懂，其中比喻是很好的既使自己内化又使别人易懂的方式\n* 准确\n## 好处\n* 真正了解学习的东西\n* 提升教导技能，真正有说服力\n* 增加自己独立思考的能力，做明智决定\n* 能学以致用\n","tags":["学习笔记"]},{"title":"算法训练营day3","url":"%2F2019%2F11%2F08%2F%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5day3%2F","content":"## 数组arraylist\n不限制类型，由内存管理器管理的一串连续内存地址的数据结构。\n查询是O(1)的复杂度\n添加，删除操作是O(n),因为涉及了很多数据的拷贝和移动\n为了解决这个添加，删除操作的问题，出现了链表\n## 链表linkList\n由头指针开始，指向第一个元素，后续的每一个元素指向下一个元素，最后的尾指针指向空。\n\n这个添加删除的时候能达到O(1)的时间复杂度\n但是查找的时候需要从头指针开始遍历，所以是O(n)的时间复杂度\n为了优化查找的问题，出现了跳表的数据结构\n## 跳表skiplist\n优化链表的思路就是升维，以空间换时间\n链表本身有头指针和尾指针，那再多几个指向其他位置的指针是不是可以节省时间呢？比如中指针专门指向链表的中部，等等\n\n于是顺着这个思路出现了分级索引，比如一级索引是隔两个一跳，二级索引是隔四个一跳....\n\n这样遍历的时候时间复杂度就从O(n)编程了log(n)\n但空间复杂度就成了O(n)\n\n## 工程应用\nredis的数据结构中应用了跳表而非红黑树\nLRU缓存 近期最少使用算法\n\n## 思维\n时间换空间/升维\n\n","tags":["数组,链表,跳表"]},{"title":"重拾数学","url":"%2F2019%2F11%2F07%2F%E9%87%8D%E6%8B%BE%E6%95%B0%E5%AD%A6%2F","tags":["数学"]},{"url":"%2F2019%2F10%2F24%2Fssh%20%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%2F","content":"![](https://spark-1300032833.cos.ap-guangzhou.myqcloud.com/blog/2019-10-24-l00ehS.png)"},{"title":"typescript上手实践","url":"%2F2019%2F10%2F22%2Ftypescript%E4%B8%8A%E6%89%8B%E5%AE%9E%E8%B7%B5%2F","content":"### typescript 工程构建\n* 新建项目文件夹\n* npm init -y\n* npm i typescript -g\n* tsc --init\n","tags":["typescript"]},{"title":"ECMAscript6学习笔记","url":"%2F2019%2F10%2F18%2FECMAscript6%E5%AD%A6%E4%B9%A0%2F","content":"### var,let,const声明变量的区别\n类型|可重复声明|作用域|性质|备注\n ---|---|---|---|---\n var |yes|函数级|变量|\n let|no|块级|变量\n const|no|块级|常量\n\n### (function(){})()之类的写法\n名称：自执行匿名函数\n\n目的：因为一般变量只要不是window下的全局变量或函数，最大的作用域也是函数级别，所以可以利用匿名函数创建一个命名空间。可以达到匿名和自动执行的功能，这也是各大js类库的做法\n \n问题：为什么要把闭包函数用括号包起来？\n    \n    答案：是为了让一个函数的生命变成一个表达式从而合法，如果没有外面的括号包围，会导致函数的生命和调用在一起，让解释器莫名其妙，理解括号的意义之后，就知道很多变种的写法都是一个道理，比如：赋值，逻辑，甚至是逗号，各种操作符\n    (function(){alert('iifksp')})()       // true\n    !function(){alert('iifksp')}()        // true\n    +function(){alert('iifksp')}()        // NaN\n    -function(){alert('iifksp')}()        // NaN\n    var i = function(){alert('iifksp')}() // undefined \n    ...\n\n从性能和兼容上来说，建议使用列出的情况之一\n### 箭头函数\n目的：1、简化，2、修正this\n\n具体：\n当参数只有一个的时候()可以省略\n当只有一个return 语句的时候{}可以省略\n~~~\nfunction test(var i){\n    ...\n}\nlet test=()=>{\n\n}\n~~~\nthis指向是其父作用域，普通写法指向调用的对象本身\n\n### 异步三部曲\npromise，generator/yield,async/await\n\n一个本质，三个时代\n\n目的为了实现封装异步的同时拥有同步编程的面孔，减少异步编程的复杂性\n\npromise.all()请求很多个资源但不分先后\nPromise.all().then(result=>{},err=>{})\n<!-- new promise((resolve,reject)=>{}) -->\n\ngenerator/yield用于处理有逻辑的异步请求\n    function *name(){\n        yield ......\n    }\nAsync/Await\n    Async function(){\n        Await .....\n    }\n\n","tags":["ECMAscript6"]},{"title":"实时音视频文档","url":"%2F2019%2F09%2F17%2F%E5%AE%9E%E6%97%B6%E9%9F%B3%E8%A7%86%E9%A2%91%E6%96%87%E6%A1%A3%2F","content":"\n# 接入流程\n### 1、引入js文件\n~~~\n<script src=\"https://rtc.visitong.com/js/WebAPI.min.js\"></script>\n~~~\n### 2、检测是否支持 WebRTC\n~~~\n<script>\nWebAPI.fn.detectRTC({\n    screenshare: false\n}, function (info) {\n    if (!info.support) {\n        alert('不支持WebRTC')\n    }\n});\n<script>\n~~~\n### 3、初始化webRTC\n~~~\nwindow.RTC = new WebAPI({\n    userId: 用户名,\n    userSig: 用户签名,从visitong服务端获取,见下面服务接口支持1\n    sdkAppId: 固定值,\n    accountType: 固定值1\n},function () {\n    // 初始化回调函数\n    // 以下的4，5，6部分都应该在这里\n}, function (error) {\n    // 错误捕获\n    console.warn(\"init error\", error)\n})\n~~~\n### 4、创建和进入音视频房间\n~~~\n//此处必须在上一个初始化webrtc的回调函数之内\n    RTC.enterRoom({\n        //房间ID只能是数字\n        roomid: opts.roomid * 1,\n        role: \"user\",\n    }, function (info) {\n        console.warn(\"init succ\", info)\n        \n    }, function (error) {\n        <!-- 初始化错误捕获 -->\n        console.error(\"init error\", error)\n    });\n~~~\n### 5、获取本地化视频流\n~~~\nRTC.getLocalStream({\n    video: true,\n    audio: true,\n    videoDevice: opt.videoDevice,\n}, function (info) {\n    <!-- 回调返回当前用户流名 -->\n    var stream = info.stream;\n    succ(stream)\n});\n~~~\n### 6、开始推流\n~~~\nRTC.startRTC({\n    stream: stream,\n    role: 'user'\n});\n~~~\n### 7、远端视频流渲染\n~~~\nRTC.on(\"onRemoteStreamUpdate\", onRemoteStreamUpdate)\n\nfunction onRemoteStreamUpdate(info) {\n    console.debug(info);\n    if (info.stream && info.stream.active === true) {\n        var id = info.videoId;\n        var video = document.getElementById(id);\n        if (!video) {\n            video = createVideoElement(id);\n        }\n        video.srcObject = info.stream;\n        $(\"#client\").html(info.userId); \n            // 混流\n\n    } else {\n        console.log('欢迎用户' + info.userId + '加入房间');\n    }    \n}\n~~~\n### 8、远端下线提醒\n~~~\nRTC.on(\"onRemoteStreamRemove\", onRemoteStreamRemove)\n\nfunction onRemoteStreamRemove(info) {\nconsole.log(info.userId + ' 断开了连接');\nvar videoNode = document.getElementById(info.videoId);\nif (videoNode) {\n    videoNode.srcObject = null;\n    document.getElementById(info.videoId).parentElement.removeChild(videoNode);\n}\n}\n~~~\n### 更多事件和功能见下面demo\n\n# 服务接口支持\n### 1、获取用户签名\n\n参数名|类型|是否必须|说明\n-----|----|------|------\ntype |string|yes|ajax操作类型\nuser_id |string|yes|用户名\n~~~\n$.ajax({\n    type: 'post',\n    url: 'https://rtc.visitong.com/ajax.php',\n    data: { type: \"rtc_user_sign\", user_id: user_id },\n    dataType: 'json',\n    success: function (res) {\n        $('#c_roomid').html(roomid);\n        $('#customer').html(userId);\n        $(\"#video-section\").show();\n        initRTC({\n            \"userId\": userId,\n            \"userSig\": res.userSig,\n            \"sdkappid\": 1400257833,\n            \"accountType\": 1,\n            \"roomid\": roomid\n        });\n    }\n})\n~~~\n### 2、获取独立画面视频流地址\n\n参数名|类型|是否必须|说明\n-----|----|------|------\ntype |string|yes|ajax操作类型\nroom_id |int|yes| 房间id\nuser_id |string|yes| 用户名\n~~~\n$.ajax({\n    type:'post',\n    url:'https://rtc.visitong.com/ajax.php',\n    data:{type:\"get_user_stream\",room_id: room_id,user_id:user_id},\n    dataType:'json',\n    success:function(res){\n        $(\"#stream_url\").html(res.stream);\n    }\n})\n~~~\n### 3、混流接口\n* 输入参数说明\n\n\b参数名|类型|是否必须|说明\n-----|----|------|------\ntype |string|yes|ajax操作类型\nroom_id |int|yes| 房间id\ncustomer |string|yes| 客服用户名\nclient |string|yes| 客户用户名\n~~~\n$.ajax({\n    type:'post',\n    url:'https://rtc.visitong.com/ajax.php',\n    data:{type: \"mix_stream\",room_id: room_id,customer: \"customer\",client: info.userId},\n    dataType:'json',\n    success:function(res){\n        console.log(res)\n    }\n})\n~~~\n* 返回参数说明\n\n\b参数名|参数值示例|说明\n-----|------|----\ncode|100或其他数字| 100为混流成功代码，其他为未成功\nmsg| success或其他| 接口返回消息\nsession_id|dgeowlj67er|混流会话ID，需要业务保存这个ID,不成功则没有\nstream|2df3fcs6nm|合并流名，不成功则没有\n\n### 4、取消合流\n* 输入参数说明\n\n\b参数名|类型|是否必须|说明\n-----|----|------|------\ntype |string|yes|ajax操作类型\nsession_id |string|yes| 混流会话id\nstream |string|yes| 混流流名\n~~~\n$.ajax({\n        type:'post',//get或post\n        url:'https://rtc.visitong.com/ajax.php',\n        data:{type: \"cancel_mix_stream\",session_id:session_id,stream:stream},\n        dataType:'json',\n        success:function(res){\n            console.log(res)\n        }\n    })\n~~~\n* 返回参数说明\n\n\b参数名|参数值示例|说明\n-----|------|----\ncode|100或其他数字| 100为混流成功代码，其他为未成功\nmsg| success或其他| 接口返回消息\n\n# demo文件\n~~~\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>webRTC demo</title>\n</head>\n<body>\n    <p>当前房间号：<span id=\"c_roomid\"></span> 当前用户： <span id=\"customer\"></span>当前客户：<span id=\"client\"></span> 当前流：<span id=\"stream_url\"></span></p>\n    <p><button id=\"mix_stream\">混流</button></p>\n\n    <!-- 视频流展示区域 -->\n    <div id=\"video-section\" style=\"display: none\">\n        <div id=\"remote-video-wrap\">\n        \n        </div>\n    </div>\n    <script src=\"./libs/jquery.min.js\"></script>\n    <script src=\"https://rtc.visitong.com/js/WebAPI.min.js\"></script>\n    <script>\n        var html = 'u' + Math.floor(Math.random() * 10000);\n        var roomid = 113356;\n        var userId = html;\n        // 检查浏览器环境是否支持WebRTC\n        WebAPI.fn.detectRTC({\n            screenshare: false\n        }, function (info) {\n            if (!info.support) {\n                alert('不支持WebRTC')\n            }\n        });\n        \n        // 触发webTC的初始化以及房间创建、本地化推流\n        push();\n        \n        // 踢出房间执行函数\n        function onKickout() {\n            alert(\"on kick out!\");\n        }\n\n        // 退出webRTC 执行函数\n        function quitRTC() {\n            RTC.quit();\n            $(\"#video-section\").hide();\n            $(\"#remote-video-wrap\").html(\"\");\n        }\n        // 服务器超时执行函数\n        function onRelayTimeout(msg) {\n            alert(\"onRelayTimeout!\" + (msg ? JSON.stringify(msg) : \"\"));\n        }\n\n        // 渲染视频执行函数，用在本地和远程视频流加入房间的时候\n        function createVideoElement(id, isLocal) {\n            var videoDiv = document.createElement(\"div\");\n            videoDiv.innerHTML = '<video id=\"' + id + '\" autoplay ' + (isLocal ? 'muted' : '') + ' playsinline ></video>';\n            document.querySelector(\"#remote-video-wrap\").appendChild(videoDiv);\n            return document.getElementById(id);\n        }\n        \n        // 本地视频流渲染\n        function onLocalStreamAdd(info) {\n            if (info.stream && info.stream.active === true) {\n                var id = \"local\";\n                var video = document.getElementById(id);\n                if (!video) {\n                    createVideoElement(id, true);\n                }\n                var video = document.getElementById(id)\n                video.srcObject = info.stream;\n                video.muted = true\n                video.autoplay = true\n                video.playsinline = true\n            }\n        }\n\n        // 加入房间的用户视频流\n        function onRemoteStreamUpdate(info) {\n            console.debug(info)\n            if (info.stream && info.stream.active === true) {\n                var id = info.videoId;\n                var video = document.getElementById(id);\n                if (!video) {\n                    video = createVideoElement(id);\n                }\n                video.srcObject = info.stream;\n                $(\"#client\").html(info.userId);\n                \n                // 混流，只做示范，具体调用时机根据业务来定\n                setTimeout(function(info){\n                    $.ajax({\n                        type:'post',//get或post\n                        url:'https://rtc.visitong.com/ajax.php',\n                        data:{type: \"mix_stream\",room_id: roomid,customer: \"customer\",client: info.userId},\n                        dataType:'json',//text\n                        success:function(res){\n                            console.log(res)\n                        }\n                    })\n                },10000);\n\n            \n            } else {\n                console.log('欢迎用户' + info.userId + '加入房间');\n            }\n        }\n\n        function onRemoteStreamRemove(info) {\n            console.log(info.userId + ' 断开了连接');\n            var videoNode = document.getElementById(info.videoId);\n            if (videoNode) {\n                videoNode.srcObject = null;\n                document.getElementById(info.videoId).parentElement.removeChild(videoNode);\n            }\n        }\n\n        function onWebSocketClose() {\n            RTC.quit();\n        }\n\n        function gotStream(opt, succ) {\n            RTC.getLocalStream({\n                video: true,\n                audio: true,\n                videoDevice: opt.videoDevice,\n                \n            }, function (info) {\n                var stream = info.stream;\n                succ(stream)\n            });\n        }\n\n        function initRTC(opts) {\n            window.RTC = new WebAPI({\n                userId: opts.userId,\n                userSig: opts.userSig,\n                sdkAppId: opts.sdkappid,\n                accountType: opts.accountType\n            }, function () {\n                RTC.enterRoom({\n                    roomid: opts.roomid * 1,\n                    role: \"user\",\n                }, function (info) {\n                    console.warn(\"init succ\", info)\n                    gotStream({\n                        audio: true,\n                        video: true\n                    }, function (stream) {\n                        RTC.startRTC({\n                            stream: stream,\n                            role: 'user'\n                        });\n                    })\n                }, function (error) {\n                    console.error(\"init error\", error)\n                });\n            }, function (error) {\n                // console.warn(\"init error\", error)\n            });\n\n            // 远端流新增/更新\n            RTC.on(\"onRemoteStreamUpdate\", onRemoteStreamUpdate)\n            // 本地流新增\n            RTC.on(\"onLocalStreamAdd\", onLocalStreamAdd)\n            // 远端流断开\n            RTC.on(\"onRemoteStreamRemove\", onRemoteStreamRemove)\n            // 重复登录被T\n            RTC.on(\"onKickout\", onKickout)\n            // 服务器超时\n            RTC.on(\"onRelayTimeout\", onRelayTimeout)\n\n            RTC.on(\"onErrorNotify\", function (info) {\n                console.error(info)\n                if (info.errorCode === RTC.getErrorCode().GET_LOCAL_CANDIDATE_FAILED) {\n                    // alert( info.errorMsg )\n                }\n            });\n            RTC.on(\"onStreamNotify\", function (info) {\n                // console.warn('onStreamNotify', info)\n            });\n            RTC.on(\"onWebSocketNotify\", function (info) {\n                // console.warn('onWebSocketNotify', info)\n            });\n            RTC.on(\"onUserDefinedWebRTCEventNotice\", function (info) {\n                // console.error( 'onUserDefinedWebRTCEventNotice',info )\n            });\n        }\n\n        function push() {\n            // 先获取用户签名\n            $.ajax({\n                type: 'post',//get或post\n                url: 'https://rtc.visitong.com/ajax.php',\n                data: { type: \"rtc_user_sign\", user_id: userId },\n                dataType: 'json',//text,j\n                success: function (res) {\n                    $('#c_roomid').html(roomid);\n                    $('#customer').html(userId);\n                    $(\"#video-section\").show();\n                    initRTC({\n                        \"userId\": userId,\n                        \"userSig\": res.userSig,\n                        \"sdkappid\": 1400257833,\n                        \"accountType\": 1, \n                        \"roomid\": roomid\n                    });\n                }\n            })\n\n            // 获取用户流地址，只做示范，实际生产中尽量用onLocalStreamAdd和onRemoteStreamUpdate代替，因为流地址延时大\n            \n            $.ajax({\n                type:'post',//get或post\n                url:'https://rtc.visitong.com/ajax.php',\n                data:{type:\"get_user_stream\",room_id: roomid,user_id:userId},\n                dataType:'json',\n                success:function(res){\n                    $(\"#stream_url\").html(res.stream);\n                }\n            })\n            \n        }\n\n        function audience() {\n            login(true);\n        }\n\n        function stopRTC() {\n            RTC.stopRTC(0, function (info) {\n                // console.debug(info)\n            }, function (info) {\n                // console.debug(info)\n            });\n        }\n\n        function stopWs() {\n            RTC.global.websocket.close();\n        }\n\n        function startRTC() {\n            RTC.startRTC(0, function (info) {\n                console.debug('success', info)\n            }, function (info) {\n                console.debug('failed', info)\n            });\n        }\n    </script>\n</body>\n</html>\n~~~\n# 本地保存合流音视频\n~~~\nffmpeg -i http://thls.visitong.com/live/sdsdasdas2343.m3u8 -c:v copy -c:a copy -bsf:a aac_adtstoasc d:\\cap.mp4\n~~~\n\n\n","tags":["webRTC"]},{"title":"微信小程序实践之直播推流","url":"%2F2019%2F09%2F17%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%9E%E8%B7%B5%E4%B9%8B%E7%9B%B4%E6%92%AD%E6%8E%A8%E6%B5%81%2F","content":"# 项目介绍\n利用小程序实现一个直播推流工具，记录一下当中的几个上手的知识点\n## 表单数据获取\n> 注意\n\n* 所有的input  textarea button全部包含在form表单元素里\n* button  必须有formType=\"submit\" 这个属性\n* form 必须有提交事件  即bindsubmit=\"back_houtai\"\n* 通过 name属性取值，name名称不可重复\n> 代码示例\n~~~\nwxml\n<form bindsubmit=\"back_houtai\">\n    <input placeholder='请输入总分' cursor-spacing='20' name='total_score'></input>\n    <input placeholder='请输入初试专业课成绩' cursor-spacing='20' name='major_score'>\n    <button class='subClass_btn2' formType=\"submit\">确定</button>\n</form>\njs\ndata: {\n\n},\nback_houtai: function (e) {\n    var that = this;\n    var total_score = e.detail.value.total_score; //总分\n    var major_score = e.detail.value.major_score; //专业分\n    var enroll_date = e.detail.value.enroll_date; //年份\n    var self_intro = e.detail.value.self_intro; //个人介绍\n    console.log(total_score)\n    console.log(major_score)\n    console.log(enroll_date)\n    console.log(self_intro)\n}\n~~~\n## 界面之间传值，取值\n* url传值\n~~~\nA页面\n// 方法一：navigator标签传值\n    <navigator url=\"/page/index/index?id=110\" >传值</navigator>\n    <navigator url=\"/page/index/index?id=110&username=jane&password=123456\" >传值</navigator>\n\n    // 方法二： wx.navigator标签传值单值、多值传递\n    wx.navigateTo({\n      url: '/page/index/index?id=' + id\n    })\n    \n    wx.navigateTo({\n      url: '/page/index/index?id=' + id +'&username='+ username+'&password='+ password\n    })\nB页面\nonLoad: function (options) {\n    var id = options.id;\n    this.setData({\n      id:id,\n      username:username,\n      password:password,\n    })\n  },\n~~~\n* 本地存储\n~~~\n<!-- 存 -->\nwx.setStorageSync('user_info', dic);\n<!-- 取 -->\nvar user_info = wx.getStorageSync(\"user_info\")\nthis.setData({\nusername: user_info.username\n});\n<!-- 删 -->\nwx.removeStorageSync(\"user_info\")\n~~~\n\n* 全局的app对象\n~~~\n<!-- app.js -->\n//用户数据\nappData: {\n    user_info:null,\n}\n<!-- 需要赋值的时候 -->\nvar app = getApp();\napp.appData.user_info = {\"username\"：\"jane\"};\n<!-- 需要取值的时候 -->\nvar app = getApp();\nvar user_info = app.appData.user_info;\nthis.setData({\n    username: user_info.username\n});\n~~~\n\n\n\n\n\n\n","tags":["微信小程序"]},{"title":"系统TPS，并发，响应时间，吞吐量评估","url":"%2F2019%2F08%2F14%2F%E7%B3%BB%E7%BB%9FTPS%EF%BC%8C%E5%B9%B6%E5%8F%91%EF%BC%8C%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%EF%BC%8C%E5%90%9E%E5%90%90%E9%87%8F%E8%AF%84%E4%BC%B0%2F","content":"# 关系\n系统吞吐量（Throughput）几个重要参数：QPS（TPS）、并发数、响应时间（RT）\n\n* QPS（TPS）：每秒钟request/事务 数量\n* 并发数： 系统同时处理的request/事务数\n* 响应时间：  一般取平均响应时间\n\n并发并不等于QPS(TPS)，因为一个query(请求)或者Trransaction（事务）并非占据全部的CPU，IO等资源，对于一个多用户的系统，如果只有一个用户使用时系统的平均响应时间是t，当有你n个用户使用时，每个用户看到的响应时间通常并不是n×t，而往往比n×t小很多（当然，在某些特殊情况下也可能比n×t大，甚至大很多），在每个时间点都可能有许多资源被闲置，当处理多个请求时，如果资源配置合理，每个用户看到的平均响应时间并不随用户数的增加而线性增加，在应用场景访问压力下，只要某一项达到系统最高值，系统的吞吐量就上不去了，如果压力继续增大，系统的吞吐量反而会下降，原因是系统超负荷工作，上下文切换、内存等等其它消耗导致系统性能下降\n\n一般来说关系是：\nQPS（TPS）= 并发数/平均响应时间\n\n# QPS\n原理：每天80%的访问集中在20%的时间里，这20%时间叫做峰值时间。\n\n公式：( 总PV数 * 80% ) / ( 每天秒数 * 20% ) = 峰值时间每秒请求数(QPS) 。\n\n机器：峰值时间每秒QPS / 单台机器的QPS = 需要的机器 。\n\n每天300w PV 的在单台机器上，这台机器需要多少QPS？\n\n( 3000000 * 0.8 ) / (86400 * 0.2 ) = 139 (QPS)。\n\n一般需要达到139QPS，因为是峰值。\n\n每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。\n\n因特网上，经常用每秒查询率来衡量域名系统服务器的机器的性能，其即为QPS。\n\n对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。\n\n# 参考资料\n1、https://www.cnblogs.com/longxiaojiangi/p/9259745.html\n\n2、http://www.ha97.com/5095.html","tags":["TPS,QPS,并发，RT"]},{"title":"mysql造数据脚本","url":"%2F2019%2F08%2F08%2Fmysql%E9%80%A0%E6%95%B0%E6%8D%AE%E8%84%9A%E6%9C%AC%2F","content":"> mysql造数据脚本\n\n~~~\nuse stu;\ndrop table if exists student;\ncreate table student\n  (  s_id int(11) not null auto_increment ,\n     sno    int(11),\n     sname varchar(50),\n     sage  int(11),\n     ssex  varchar(8) ,\n     father_id int(11),\n      mather_id int(11),\n      note varchar(500),\n     primary key (s_id),\n   unique key uk_sno (sno)\n  ) engine=innodb default charset=utf8mb4;\ntruncate table student;\n  delimiter $$\ndrop function if exists   insert_student_data $$\ncreate function insert_student_data()\n returns  int deterministic\n    begin\n    declare  i int;\n      set i=1;\n      while  i<50000000 do\n      insert into student  values(i ,i, concat('name',i),i,case when floor(rand()*10)%2=0 then 'f' else 'm' end,floor(rand()*100000),floor(rand()*1000000),concat('note',i) );\n      set i=i+1;\n      end while;\n      return 1;\n    end$$\ndelimiter ;\nselect  insert_student_data();\nselect count(*) from student;\nuse stu;\ncreate table course\n  (\n     c_id int(11) not null auto_increment ,\n     cname varchar(50)\n     note varchar(500), primary key (c_id)\n  )  engine=innodb default charset=utf8mb4;\ntruncate table course;\n  delimiter $$\ndrop function if exists   insert_course_data $$\ncreate function insert_course_data()\n returns  int deterministic\n    begin\n    declare  i int;\n      set i=1;\n      while  i<=1000 do\n      insert into course  values(i , concat('course',i),floor(rand()*1000),concat('note',i) );\n      set i=i+1;\n      end while;\n      return 1;\n    end$$\ndelimiter ;\nselect  insert_course_data();\nselect count(*) from course;\nuse stu;\ndrop table if exists sc;\ncreate table sc\n  (\n     s_id    int(11),\n     c_id    int(11),\n     t_id    int(11),\n     score int(11)\n  )  engine=innodb default charset=utf8mb4;\ntruncate table sc;\n  delimiter $$\ndrop function if exists   insert_sc_data $$\ncreate function insert_sc_data()\n returns  int deterministic\n    begin\n    declare  i int;\n      set i=1;\n      while  i<=50000000 do\n      insert into sc  values( i,floor(rand()*1000),floor(rand()*10000000),floor(rand()*750)) ;\n      set i=i+1;\n      end while;\n      return 1;\n    end$$\ndelimiter ;\nselect  insert_sc_data();\ncommit;\nselect  insert_sc_data();\ncommit;\ncreate index idx_s_id  on sc(s_id)   ;\ncreate index idx_t_id  on sc(t_id)   ;\ncreate index idx_c_id  on sc(c_id)   ;\nselect count(*) from sc;\nuse stu;\ndrop table if exists teacher;\ncreate table teacher\n  (\n    t_id  int(11) not null auto_increment ,\n     tname varchar(50) ,\n     note varchar(500),primary key (t_id)\n  )  engine=innodb default charset=utf8mb4;\n\n  truncate table teacher;\n  delimiter $$\ndrop function if exists   insert_teacher_data $$\ncreate function insert_teacher_data()\n returns  int deterministic\n    begin\n    declare  i int;\n      set i=1;\n      while  i<=10000000 do\n      insert into teacher  values(i , concat('tname',i),concat('note',i) );\n      set i=i+1;\n      end while;\n      return 1;\n    end$$\ndelimiter ;\nselect  insert_teacher_data();\ncommit;\nselect count(*) from teacher;\n~~~","tags":["mysql"]},{"title":"监控预警系统方案调研","url":"%2F2019%2F08%2F03%2F%E7%9B%91%E6%8E%A7%E9%A2%84%E8%AD%A6%E7%B3%BB%E7%BB%9F%E6%96%B9%E6%A1%88%E8%B0%83%E7%A0%94%2F","content":"\ntelegraf 收集数据\ninfluxDB 存储数据\ngrafana 展示数据\n\n这和ELK的优缺点待查\n\n在展示上kibana还是不如grafana\n\n> 安装\n~~~\n安装grafana\nGrafana是一个纯html/js的web应用，是一个开源仪表盘工具，访问InfluxDB时不会存在跨域访问的限制，只要配置好数据源后，即可展示监控数据。\n docker run \\\n  -d \\\n  -p 3000:3000 \\\n  --name grafana \\\n  grafana/grafana:5.1.0\n\n安装influxDB\nInfluxDB 是一个开源分布式时序、事件和指标数据库。使用 Go 语言编写，无需外部依赖。其设计目标是实现分布式和水平伸缩扩展。\n\ndocker create -p 8083:8083 -p 8086:8086 -v /opt/influxdb:/var/lib/influxdb --name=influxdb --hostname=influxdb tutum/influxdb\n\ndocker start influxdb\n打开http://******:8083/，这是influxDB的web管理界面\n新建数据库mlink\n新增用户名telegraf，密码telegraf\n\n安装telegraf\n\nTelegraf是一个用Go语言编写的代理程序，可采集系统和服务的统计数据，并写入InfluxDB数据库。Telegraf具有内存占用小的特点，通过插件系统开发人员可轻松添加支持其他服务的扩展\n\nwget https://dl.influxdata.com/telegraf/releases/telegraf-1.7.4-1.x86_64.rpm\nyum localinstall telegraf-1.7.4-1.x86_64.rpm \n\nvim /etc/telegraf/telegraf.conf\n修改如下配置项\n[[outputs.influxdb]]\n  ## The full HTTP or UDP URL for your InfluxDB instance.\n  urls = [\"http://127.0.0.1:8086\"]\n\n  ## The target database for metrics; will be created as needed.\n  database = \"telegraf\"\n\n  ## Name of existing retention policy to write to.  Empty string writes to\n  ## the default retention policy.  Only takes effect when using HTTP.\n   retention_policy = \"\"\n\n  ## Timeout for HTTP messages.\n   timeout = \"5s\"\n\n  ## HTTP Basic Auth\n  username = \"telegraf\"\n  password = \"telegraf\"\n\nsystemctl start telegraf\n\n安装grafana面板\n1、在https://grafana.com/grafana/dashboards 搜索Dynamic Dashboard，复制ID，\n2、在grafana中导入dashboard即可\n~~~\n> 预警\n编辑监控指标设置规则即可预警\n\n参考链接\nhttps://www.jianshu.com/p/fe11d681bd58\n","tags":["telegraf,influxDB,grafana"]},{"title":"ios推流端修改打包上线","url":"%2F2019%2F07%2F30%2Fios%E6%8E%A8%E6%B5%81%E7%AB%AF%E4%BF%AE%E6%94%B9%E6%89%93%E5%8C%85%E4%B8%8A%E7%BA%BF%2F","content":"# 概述\n本笔记记录将七牛的ios推流端修改定制打包上线的过程，因为平常不常用ios开发工具，特此记录。\n\n> 环境\n\n* xcode 9.3\n* macOS 10.14\n* code:\nhttps://github.com/pili-engineering/PLMediaStreamingKit.git\n\n> 过程\n* gem安装\n\n    gem是object-c和swift的依赖包管理工具，等同与python的pip，php的conposer，node的npm等\n    \n    1、 命令：sudo gem install cocospods\n\n    2、 可能问题：镜像错误，下载404\n    解决：\n    ~~~\n    #移除失效的\n    gem sources --remove https://rubygems.org/\n    #添加有效的\n    gem sources -a https://gems.ruby-china.com/\n    #验证\n    gem sources -l\n    #重新安装\n\n    ~~~\n* 知识补充\n\n    1、Certificates 开发者证书分为开发（iOS Development）和发布（iOS Distribution）两种类型。\n    这个是最基础的，用来证明自己是开发者身份的。里面还包含推送APNS推送证书，推送证书也是分为开发和发布两种类型。\n\n    2、App IDs：这是每个应用的独立标识，在设置项中可以配置该应用的权限\n    APP id对应工程里的bundleID，唯一。比如是否用到了PassBook，GameCenter，以及更常见的push服务。如果选中了Push服务，那么就可以创建生成上面第一条所提到的推送证书。\n\n    3、Devices测试机器绑定\n\n    4、Provisioning Profiles：描述文件，也称为PP文件\n    该文件将AppID、开发者证书、硬件Device绑定到一块儿，在开发者中心配置好后可以添加到Xcode上，也可以直接在Xcode上连接开发者中心生成。真机调试时需要在PP文件中添加真记得udid\n    http://www.cocoachina.com/cms/wap.php?action=article&id=25809","tags":["ios"]},{"title":"开源ELK统一日志平台实践","url":"%2F2019%2F07%2F02%2F%E5%BC%80%E6%BA%90ELK%E7%BB%9F%E4%B8%80%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0%E5%AE%9E%E8%B7%B5%2F","content":"# ELK开源统一日志系统实践\n\n## 编译安装\n\n### 环境\n10.10.10.245 filebeat+nginx\n\n10.10.10.15 elasticsearch\n\n10.10.10.10 logstash\n~~~\n1、下载安装包\n\nwget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.2.0-linux-x86_64.tar.gz\nwget https://artifacts.elastic.co/downloads/kibana/kibana-7.2.0-linux-x86_64.tar.gz\nwget https://artifacts.elastic.co/downloads/logstash/logstash-7.2.0.tar.gz\nwget https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-7.2.0-linux-x86_64.tar.gz\n\n2、解压\n\ntar zxvf ***\n\n3、新建用户组\n\ngroupadd elasticsearch\nuseradd elasticsearch -g elasticsearch\n\nmkdir /elk\n\nmv **解压文件 /elk\n\nchown -R elasticsearch.elasticsearch /elk\n\nsu elasticsearch\n\n4、启动Elasticsearch\n\nnohup /elk/elasticsearch-7.2.0/bin/elasticsearch -d > /elk/runlog/elasticsearch.log 2>&1 &\n\n5、配置logstash \n\nvi logstash-nginx-es.conf\n\ninput {\n    beats {\n        host => \"0.0.0.0\"\n        port => 5400\n    }\n}\n\nfilter {\n   grok {\n      match => { \"message\" => \"%{IPORHOST:remote_ip} - %{DATA:user_name} \\[%{HTTPDATE:access_time}\\] \\\"%{WORD:http_method} %{DATA:url} HTTP/%{NUMBER:http_version}\\\" %{NUMBER:response_code} %{NUMBER:body_sent_bytes} \\\"%{DATA:referrer}\\\" \\\"%{DATA:agent}\\\"\" }\n        }\n}\n\noutput {\n elasticsearch {\n   hosts => [\"124.232.150.15:9200\"]\n   index => \"nginx_index_pattern-%{+YYYY.MM.dd}\"    #这个weblogs_index_pattern就是kibana里面的index_pattern,可以改成自定义的名字\n }\n stdout { codec => rubydebug }\n}\n\nnohup /usr/local/src/logstash-7.2.0/bin/logstash -f \n/usr/local/src/logstash-7.2.0/config/nginx_log.conf>/usr/local/src/runlog/logstash.log 2>&1 &\n\n6、配置并启动kibana\nserver.port: 5601\nserver.host: \"0.0.0.0\"\nelasticsearch.hosts: [\"http://124.232.150.15:9200\"]\npid.file: /elk/kibana-7.2/kibana.pid\n\nnohup /elk/kibana-7.2/bin/kibana > /elk/runlog/kibana.log 2>&1 &\n\n7、配置收集器filebeat\nvim filebeat.yml\n\nfilebeat.inputs:\n- type: log\n    enabled: true\n    paths:\n        - /home/data/nginx_log/*.log\n\noutput.logstash:\n    hosts: [\"124.232.150.10:5400\"]\n\nnohup /usr/local/src/filebeat-7.2/filebeat -e -c /usr/local/src/filebeat-7.2/filebeat.yml >/usr/local/src/filebeat-7.2/filebeat-7.2/filebeat.log & \n~~~\n## 参考资料\n\n[配置kibana dashboard](https://www.codercto.com/a/36757.html)\n\n[logstash Grok配置](https://www.codercto.com/a/37248.html)\n\n## 扩展\n* 自定义数据类型展示在kibana的面板上\n* kibana与grafana的对比和选择\n","tags":["ELK 日志"]},{"title":"面试题","url":"%2F2019%2F06%2F05%2F%E9%9D%A2%E8%AF%95%E9%A2%98%2F","content":"# 运维\n环境：24核2.0Ghz，32G，1T，nginx+php-fpm+mysql单台部署\n表现是页面出现排队现象，有时能进有时不能进。cpu load average: 5.84, 5.96, 5.06\n请问排查思路和解决办法？\n排队现象极有可能是有些进程缓慢导致堵塞，文件句柄到达极限引起，CPU资源，内存资源紧张。\n\nlinux内核+tcp连接优化\nphp-fpm结合日志优化\nmysql慢日志查询\nnginx日志\n# 网络基础\ntcp协议 \n进程\ntcp\nsocket \nfd\n\n每个tcp连接都对应一对socket，返回的socket是一个fd\n\n多个http请求因为http1.1之后支持持久连接，可以多个请求共用一个连接\n\ni/o模型【多路复用/异步/阻塞/非阻塞】\nselect，poll/epoll\nhttps://www.jianshu.com/p/397449cadc9a\n        select    poll    epoll\n实现方式 array      链表    hash表\n\n\nhttp请求\n\n\n\n\nCPU  内存  网络带宽资源\n\n\n\n\n","tags":["面试"]},{"title":"wireguard实践","url":"%2F2019%2F06%2F04%2Fwireguard%E5%AE%9E%E8%B7%B5%2F","content":"~~~\n//https://github.com/l-n-s/wireguard-install.git\n\nwget https://raw.githubusercontent.com/l-n-s/wireguard-install/master/wireguard-install.sh -O wireguard-install.sh\nbash wireguard-install.sh\n\n~~~","tags":["wireguard,vpn"]},{"title":"mqtt系列上手实践","url":"%2F2019%2F05%2F16%2Fmqtt%E7%B3%BB%E5%88%97%E4%B8%8A%E6%89%8B%E5%AE%9E%E8%B7%B5%2F","content":"# 简介\n    MQTT 全称为 Message Queuing Telemetry Transport（消息队列遥测传输）是一种基于发布/订阅范式的“轻量级”消息协议，由 IBM 发布。\n    \n    MQTT 可以被解释为一种低开销，低带宽占用的即时通讯协议，可以用极少的代码和带宽的为连接远程设备提供实时可靠的消息服务，它适用于硬件性能低下的远程设备以及网络状况糟糕的环境下，因此 MQTT 协议在 IoT（Internet of things，物联网），小型设备应用，移动应用等方面有较广泛的应用。\n    \n    IoT 设备要运作，就必须连接到互联网，设备才能相互协作，以及与后端服务协同工作。而互联网的基础网络协议是 TCP/IP，MQTT 协议是基于 TCP/IP 协议栈而构建的，因此它已经慢慢的已经成为了 IoT 通讯的标准。\n\n    协议中主要有三种身份：发布者（Publisher）、代理（Broker，服务器）、订阅者（Subscriber）。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，而消息发布者可以同时是订阅者，实现了生产者与消费者的脱耦。\n\n    协议有三种消息发布的服务质量：\n        至多一次，消息发布完全依赖底层 TCP/IP 网络。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送。\n\n        至少一次，确保消息到达，但消息重复可能会发生。\n\n        只有一次，确保消息到达一次。这一级别可用于如下情况，在计费系统中，消息重复或丢失会导致不正确的结果。\n\n# 基本概念\n\n* MQTT 客户端\n    一个使用 MQTT 协议的设备、应用程序等，它总是建立到服务器的网络连接。\n    1、可以发布信息，其他客户端可以订阅该信息\n    2、订阅其它客户端发布的消息\n    3、退订或删除应用程序的消息\n    4、断开与服务器连接\n* MQTT 服务器\n    MQTT 服务器以称为 Broker（消息代理），以是一个应用程序或一台设备。它是位于消息发布者 和订阅者之间\n    1、接受来自客户端的网络连接\n    2、接受客户端发布的应用信息\n    3、处理来自客户端的订阅和退订请求\n    4、向订阅的客户转发应用程序消息\n* 主题（Topic）\n    连接到一个应用程序消息的标签，该标签与服务器的订阅相匹配。服务器会将消息发送给订阅所匹配标签的每个客户端。\n    1、要订阅的主题。一个主题可以有多个级别，级别之间用斜杠字符分隔。例如，/world 和 emq/emqtt/emqx 是有效的主题。\n    2、订阅者的Topic name支持通配符#和+ ：\n        # 支持一个主题内任意级别话题\n        +只匹配一个主题级别的通配符\n    3、客户端成功订阅某个主题后，代理会返回一条 SUBACK 消息，其中包含一个或多个 returnCode 参数\n* QoS（消息传递的服务质量水平）\n    服务质量，标志表明此主题范围内的消息传送到客户端所需的一致程度。\n    1、值 0：不可靠，消息基本上仅传送一次，如果当时客户端不可用，则会丢失该消息。\n    2、值 1：消息应传送至少 1 次。\n    3、值 2：消息仅传送一次。\n* 订阅（Subscription）\n    订阅包含主题筛选器（Topic Filter）和最大服务质量（QoS）。订阅会与一个会话（Session）关联。一个会话可以包含多个订阅。每一个会话中的每个订阅都有一个不同的主题筛选器。\n    1、客户端在成功建立TCP连接之后，发送CONNECT消息，在得到服务器端授权允许建立彼此连接的CONNACK消息之后，客户端会发送SUBSCRIBE消息，订阅感兴趣的Topic主题列表（至少一个主题）\n    2、订阅的主题名称采用UTF-8编码，然后紧跟着对应的QoS值\n* 发布（publish）\n    控制报文是指从客户端向服务端或者服务端向客户端传输一个应用消息，MQTT 客户端发送消息请求，发送完成后返回应用程序线程\n    比如安卓的推送服务，还有一些即时通信软件如微信等也是采用的推送技术。\n\n[参考资料](https://www.jianshu.com/p/ecde412d2eeb)\n\n# mosiquitto\n","tags":["MQTT,Mosquitto,rabbitMQ"]},{"title":"raspberry树莓派上手实践","url":"%2F2019%2F04%2F29%2Fraspberry%E4%B8%8A%E6%89%8B%E5%AE%9E%E8%B7%B5%2F","content":"# 树莓派智能家居实践\n\nMac环境下：\n\n* 刷入系统\n    > [balenaEtcher-1.5.24](https://www.balena.io/etcher/)\n\n    > [Raspbian](http://downloads.raspberrypi.org/raspbian_latest)\n* 开启root账号\n    ~~~\n    vi /etc/ssh/sshd_config\n    PermitRootLogin yes\n    ~~~\n* 添加swap\n    ~~~\n    vi /etc/dphys-swapfile\n    设置CONF_SWAPSIZE为2000\n    /etc/init.d/dphys-swapfile restart\n    ~~~\n\n* 远程\n    由于没有桌面服务，就算开机也不能进入系统来操作，如果有网线的话直接把网线插入树莓派即可联网，如果没有网线，只有 wifi 的话，就需要设置 wifi 的网络配置。\n\n    其实操作方法是很简单的：只要将刷好 Raspbian 系统的 SD 卡用电脑读取。在 boot 分区，也就是树莓派的 /boot 目录下新建 wpa_supplicant.conf 文件，按照下面的参考格式填入内容并保存到 wpa_supplicant.conf 文件即可。\n    ~~~\n    country=CN\n    ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev\n    update_config=1\n\n    network={\n    ssid=\"WiFi1\"\n    psk=\"12345678\"\n    key_mgmt=WPA-PSK\n    priority=1\n    }\n\n    network={\n    ssid=\"WiFi-2\"\n    psk=\"12345678\"\n    key_mgmt=WPA-PSK\n    priority=2\n    scan_ssid=1\n    }\n    ~~~\n    说明以及不同安全性的 WiFi 配置示例：\n    ~~~\n    ssid:网络的ssid\n    psk:wifi的密码\n    priority:连接优先级，数字越大优先级越高（不可以是负数）\n    scan_ssid:连接隐藏WiFi时需要指定该值为1\n    \n\n    如果您的 WiFi 没有密码\n    network={\n    ssid=\"你的无线网络名称（ssid）\"\n    key_mgmt=NONE\n    }\n    如果您的 WiFi 使用WEP加密\n    network={\n    ssid=\"你的无线网络名称（ssid）\"\n    key_mgmt=NONE\n    wep_key0=\"你的wifi密码\"\n    }\n    如果您的 WiFi 使用WPA/WPA2加密\n    network={\n    ssid=\"你的无线网络名称（ssid）\"\n    key_mgmt=WPA-PSK\n    psk=\"你的wifi密码\"\n    }\n    ~~~\n\n    开机+联网之后找到对应的IP，ssh连接上树莓派，注意没有ssh服务的话在SD卡根目录touch ssh。初始登录用户密码：pi/raspberry\n\n    > [VNC](https://www.cnblogs.com/softidea/p/3761984.html) \n    ~~~\n    sudi -i\n\n    apt-get install xrdp\n    apt-get install tightvncserver\n\n    vncserver :1 -geometry 800x600\n\n    默认端口一般是5901\n    具体可以在/root/.vnc下的日志中查看\n    ~~~\n\n    mac端安装VNC client，我选择chrome插件，可以多种选择，在[这里](https://www.realvnc.com/en/connect/download/viewer/)下载。\n\n    # frp 内网穿透\n    wget https://github.com/fatedier/frp/releases/download/v0.27.0/frp_0.27.0_linux_arm.tar.gz\n    tar zxvf frp***\n    mv frp*** /usr/local/frp\n    vi frpc.ini\n    ......\n\n* 更改软件源\n    ~~~\n    # 1、修改树莓派Raspbian 系统源,注释原有的，添加中科大的\n    vim /etc/apt/sources.list\n\n    deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi \n\n    # 2、修改debian软件源\n    vim /etc/apt/sources.list.d/raspi.list\n\n    deb http://mirrors.ustc.edu.cn/archive.raspberrypi.org/debian/ stretch main ui\n    \n    # 3、更改pip的国内的源\n    vi /etc/pip.conf\n    # 重新写入\n    [global]\n    index-url = https://pypi.mirrors.ustc.edu.cn/simple/\n\n    [install]\n    trusted-host = pypi.mirrors.ustc.edu.cn\n    \n    apt-get update\n    ~~~\n\n* 安装docker\n     ~~~\n    curl -fsSL https://get.docker.com -o get-docker.sh\n    sudo sh get-docker.sh\n\n    apt-get install -y apt-transport-https\n    apt-get install docker-compose\n    ~~~\n* 安装Home Assistant\n    ~~~\n    #升级python3.5以上版本[参考](http://blog.lxx1.com/3214)\n    apt-get install build-essential libsqlite3-dev sqlite3 bzip2 libbz2-dev\n    wget https://www.python.org/ftp/python/3.6.1/Python-3.6.1.tgz\n    tar zxvf Python-3.6.1.tgz\n    cd Python-3.6.1\n    ./configure && sudo make && sudo make install\n    which python\n    which python3\n\n    mv /usr/bin/python /usr/bin/python2.7.13\n    ln -s /usr/local/bin/python3 /usr/bin/python\n\n    # 安装HA\n    docker pull homeassistant/raspberrypi3-homeassistant\n    docker run -d --name=\"home-assistant\" -v /config:/config -v /etc/localtime:/etc/localtime:ro --net=host homeassistant/raspberrypi3-homeassistant\n\n    http://ip:8123\n\n    #安装hass.io\n    \n    [github](https://github.com/home-assistant/hassio-installer)\n    \n    curl -sL https://raw.githubusercontent.com/home-assistant/hassio-installer/master/hassio_install.sh | bash -s -- -m raspberrypi3\n\n* DIY zigbee 网关\n    \n    [参考](https://gadget-freakz.com/diy-zigbee-gateway/)\n\n    ~~~\n    ls -l /dev/ttyACM0\n    apt-get install autoconf automake libtool -y\n    apt-get install libusb-1.0, libboost-all-dev -y\n    git clone https://github.com/dashesy/cc-tool.git\n    cd cc-tool\n    ./bootstrap \n    ./configure\n    make\n    --Download the firmware\n    wget https://raw.githubusercontent.com/Koenkk/Z-Stack-firmware/master/coordinator/CC2531/bin/CC2531ZNP-Prod.hex\n    --or:\n    curl https://raw.githubusercontent.com/Koenkk/Z-Stack-firmware/master/coordinator/CC2531/bin/CC2531ZNP-Prod.hex -o CC2531ZNP-Prod.hexsudo ./cc-tool -e -w CC2531ZNP-Prod.hex\n\n    #install nodejs\n    curl -sL https://deb.nodesource.com/setup_12.x | sudo -E bash -\n    apt-get install -y nodejs git make g++ gcc\n\n    git clone https://github.com/Koenkk/zigbee2mqtt.git /opt/zigbee2mqtt\n    cd /opt/zigbee2mqtt\n    npm install\n\n    #搭建emqx做mqtt broker\n\n\n    此处未完待续\n    ~~~\n* 手机当摄像头监控\n    ~~~\n    android_ip_webcam:\n    - host: 192.168.8.100\n        name: spark camera\n        username: admin\n        password: spark0524\n        sensors:\n        - audio_connections\n        - video_connections\n        - battery_level\n        - battery_temp\n        - light\n        - motion\n        - pressure\n        switches:\n        - exposure_lock\n        - ffc\n        - focus\n        - gps_active\n        - night_vision\n        - overlay\n        - torch\n        - whitebalance_lock\n        - video_recording\n        motion_sensor: TRUE\n    ~~~\n\n* wifi设备接入 [参考](https://bbs.hassbian.com/thread-5500-1-1.html)\n    \n    1、打开米家ios app,配置好智能设备\n\n    2、手机连接itunes，无加密备份\n    \n    3、下载安装ibackup viewer，并打开上面的备份数据\n    \n    4、找到com.xiaomi.mihome下的文件中有一个******_mihome.sqlite，拷贝出来\n    \n    5、预备一个python3.5以上的版本环境，系统安装sqlite-devel\n    \n    6、pip3 install python-miio，小米wifi设备使用miio 协议\n    \n    7、miio-extract-tokens --dump-all  ******_mihome.sqlite即可获得token\n\n    yeelight灯需要的是ip以及结合yeelight app中的设置局域网控制开启\n    ~~~\n    devices:\n      192.168.0.109:\n        name: Living Room\n        transition: 1000\n    ~~~\n    \n\n","tags":["树莓派,raspberry"]},{"title":"docker搭建ftp","url":"%2F2019%2F04%2F29%2Fdocke%E6%90%AD%E5%BB%BAftpd%2F","content":"# 搭建记录\n~~~\n    docker pull stilliard/pure-ftpd:hardened\n\n    docker run --rm -d --name ftpd_server -p 21:21 -p 30000-30009:30000-30009 -v /usr/local/src/pure_ftp:/pure_ftp stilliard/pure-ftpd:hardened bash /run.sh -c 30 -C 10 -l puredb:/etc/pure-ftpd/pureftpd.pdb -E -j -R -P localhost -p 30000:30059\n\n    docker run -d --name ftpd_server -p 21:21 -v /usr/local/src/pure_ftp:/pure_ftp -v /config:/pure_ftp/config -e \"PUBLICHOST=localhost\" stilliard/pure-ftpd:hardened\n\n    docker exec -it ftpd_server bash\n\n    groupadd ftpgroup\n    useradd ftpuser -g ftpgroup -d /pure_ftp -s /sbin/nologin\n\n    pure-pw useradd spark -u ftpuser -g ftpgroup -d /pure_ftp\n    \n    pure-pw mkdb\n\n    /etc/init.d/pure-ftpd restart\n~~~","tags":["pure_ftpd"]},{"title":"百度网盘限制解除","url":"%2F2019%2F04%2F28%2F%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E9%99%90%E5%88%B6%E8%A7%A3%E9%99%A4%2F","content":"## 百度网盘限制解除\n\n* 本地安装aria2 client: Aria2GUI-v1.4.1.zip\n* 安装谷歌浏览器插件\n~~~\ngit clone https://github.com/acgotaku/BaiduExporter.git\n\ncheck Developer mode -> Load unpacked extension, navigate to the chrome/release folder\n~~~\n\n打开aria2 client，再在chrome浏览器中打开百度网盘文件页面，自动会有插件解析出下载地址，client自动下载\n\n\n\n","tags":["百度网盘"]},{"title":"php项目容器化","url":"%2F2019%2F04%2F19%2Fphp%E9%A1%B9%E7%9B%AE%E5%AE%B9%E5%99%A8%E5%8C%96%2F","content":"## 背景\n    一些公司php小项目，需要方便快速构建部署，期望能在一台空白的机器上，直接使用docker-compose即可部署\n## 步骤\n### 搭建registry harbor\n    网上和本地笔记都有，不多说\n### build images\n     \n","tags":["php,docker"]},{"title":"mysql索引认知","url":"%2F2019%2F04%2F17%2Fmysql%E7%B4%A2%E5%BC%95%E8%AE%A4%E7%9F%A5%2F","content":"## mysql索引认知历程\n\n* mysql索引是一个有助于数据查询而冗余出来的一个数据结构\n* 数据结构演变\n\n1、二叉查找树\n    I/O次数多\n    节点空间浪费   \n2、多路平衡查找树\n    页（数据块）中存储的是关键字，行数据，子节点引用\n3、多路平衡查找树（plus）\n    页中存储的是关键字，子节点引用，注意没有数据区，数据全在叶子节点，叶子节点天然有序，所以排序能力，扫库扫表能力更强,子树的关键字是n，而b树是n-1个。\n* 存储引擎\n\n1、myisam\nmyi文件是索引，叶子节点保存的是一个引用，指向myd文件，主键索引和辅助索引都是在一个文件中，没有特别区分。\n\n2、innodb\n索引和数据在一个文件\n叶子节点以聚集索引组织文件，即叶子节点存储了数据，不是像myisam的存储指针。主键索引和辅助索引有明显区分，辅助索引的叶子节点保存的是对应的主键索引关键字，再通过主键索引关键字去查主键索引的B+树，从而得到数据。这是为了减少索引的维护成本。所以innodb中主键就是聚集索引，非主键的索引就是非聚集索引。\n\n## 聚集索引\n聚集索引的标准是该索引中键值的逻辑顺序决定了表中相应行的物理顺序\n\n聚集索引对应的缺点就是修改慢，因为为了保证表中记录的物理和索引顺序一致，在记录插入的时候，会对数据页重新排序\n\nMYISAM根本就没有 聚集索引\nINNODB，主键就是 聚集索引，你也无法修改，每张InnoDB表只能创建一个聚集索引，聚集索引可以由一列或多列组成。首先选择显式定义的主键索引做为聚集索引；\n如果没有，则选择第一个不允许NULL的唯一索引；还是没有的话，就采用InnoDB引擎内置的ROWID作为聚集索引；\n\n## 覆盖索引\n覆盖索引就是由索引直接返回查询数据，往往在联合索引中需要注意利用\n\n## 怎么选择\n◆你的数据库有外键吗？   \n◆你需要事务支持吗？   \n◆你需要全文索引吗？   \n◆你经常使用什么样的查询模式？   \n◆你的数据有多大？  \n◆为什么一个节点为1页（16K）就够了？\n\n　　对着上面Mysql中Innodb中对B+树的实际应用（主要看主键索引），可以发现B+树中的一个节点存储的内容是：\n\n　　　　1. 非叶子节点：主键 + 指针\n\n　　　　2. 叶子节点：数据\n\n　　那么，假设我们一行数据大小为1K，那么一页就能存16条数据，也就是一个叶子节点能存16条数据；再看非叶子节点，假设主键ID为bigint类型，那么长度为8B，指针大小在Innodb源码中为6B，一共就是14B，那么一页里就可以存储16K/14=1170个(主键+指针)，那么一颗高度为2的B+树能存储的数据为：1170 * 16=18720条，一颗高度为3的B+树能存储的数据为：1170 * 1170 * 16=21902400（千万级条）。所以在InnoDB中B+树高度一般为1-3层，它就能满足千万级的数据存储。在查找数据时一次页的查找代表一次IO，所以通过主键索引查询通常只需要1-3次IO操作即可查找到数据。所以也就回答了我们的问题，1页=16k这么设置是比较合适的，是适用大多数的企业的，当然这个值是可以修改的，所以也能根据业务的时间情况进行调整。 ","tags":["mysql"],"categories":["db"]},{"title":"consul实践","url":"%2F2019%2F04%2F10%2Fconsul%E5%AE%9E%E8%B7%B5%2F"},{"title":"zookeeper实践","url":"%2F2019%2F04%2F10%2Fzookeeper%E5%AE%9E%E8%B7%B5%2F","content":"# 前言\n\n## 分布式系统的不可能三角\n* Consistance (一致性)\n* Availability（可用）\n* Partition Tolerance（分区容错）\n\n移动互联网中的节奏越来越快，数据的一致性很重要\n\n## 分布式中的一致性问题解决方案  \n    \n* 强一致性\n  * 数据库主从同步，主库等待从库返回写入成功信号才继续，这样CA无法满足\n  * Paxos\n  * Raft \n  * ZAB\n\n* 弱一致性（最终一致性）\n  \n  * DNS\n  * gossip协议（Cassandra）\n\n## 明确分布式系统CA存在问题与解决的思路 \n\n    1.数据不是单点，才叫分布式\n    2.不是单点，那就首先需要解决多个节点之间的数据一致性\n    3.多个节点时会出现一个名词：state machine replication （状态机复制）\n        也就是一台机器发生改变的数据状态会以类似日志的形式记录下来，然后复制到多个节点上完成多个节点之间的数据转移。看来互联网的实质就是数据的移动也有一定道理。\n    4 显然问题转变为多个节点之间如何达成共识的问题（consensus）\n        就是这些日志数据如何能都被节点机器正确有序的接收。因为互联网传输以及节点环境\b等因素在这中间就存在很多问题需要商量和确定，所以需要达成共识（consensus）\n    5 业界一般会把 state machine之间的consensus 等同与一致性。其实中间有一些差别，因为除了共识算法，还需要client的参与支持，比如主从同步中，可以用多数派的方法（共识算法）来解决一致性，但是最终完成一致性需要客户端能有序的执行指令才能做到。\n    6 共识算法paxos应运而生\n        灵魂在于多数派的思想，只是有变种\n        * basic paxos【乌托邦民主共和国】\n            著名的两阶段提交，这个容易导致活锁，就是在第一阶段提案时遭遇别人提案后，重新提案，最终冤冤相报何时了...因为效率低，难实现所以就有了multi paxos\n\n        * multi paxos【总统法治三权分立？】\n            引入了leader的概念，就是提案者，唯一的，从此结束了群雄争霸的局面，有了leader就很好解决共识，因为提案都是一个发起，相当于减少了一个阶段的提交。那它如何保证可用性呢？此时涉及到选举的问题。当主节点出现问题之后，如何迅速有继任者。\n        \n        * raft可以理解是multi paxos的极简版，这里有https://raft.github.io/\n            raft划分为三个问题：\n                * leader选举\n                * 日志复制\n                * 确保一致性\n            raft 划分为3种或两种角色\n                * leader/candidate\n                * follow\n        * ZAB协议类似raft，都是multi paxos，一些称呼不同，leader周期zab叫epoch，raft为term，心跳方向相反，raft从上至下，zab自下而上。\n\n## zookeeper的应用场景\n\n* 分布式应用配置管理\n  \n  发布与订阅即所谓的配置管理，顾名思义就是将数据发布到zk节点上，供订阅者动态获取数据，实现配置信息的集中式管理和动态更新。例如全局的配置信息，地址列表等就非常适合使用。\n* 分布式通知/协调\n  \n  ZooKeeper中特有watcher注册与异步通知机制，能够很好的实现分布式环境下不同系统之间的通知与协调，实现对数据变更的实时处理，使用方法：通常是不同系统都对ZK上同一个znode进行watch，监听znode的变化（包括znode本身内容及子节点的），其中一个系统update了 znode，那么另一个系统能够收到通知，并作出相应处理。\n* 分布式锁\n  \n  分布式锁，这个主要得益于ZooKeeper为我们保证了数据的强一致性，zk集群中任意节点（一个zk server）上的相同znode的数据是一定是相同的。\n  锁服务可以分为两类，一个是保持独占，另一个是控制时序\n* 集群管理\n  \n  Hbase Master选举则是zookeeper经典的使用场景\n* 分布式队列\n\n个人觉得主要是前两个应用\n\n## 实践操作\n\ndocker-compose.yml\n\n~~~\nversion: '3.1'\n\nservices:\n  zoo1:\n    image: zookeeper\n    restart: always\n    hostname: zoo1\n    ports:\n      - 2181:2181\n    environment:\n      ZOO_MY_ID: 1\n      ZOO_SERVERS: server.1=0.0.0.0:2888:3888 server.2=zoo2:2888:3888 server.3=zoo3:2888:3888\n\n  zoo2:\n    image: zookeeper\n    restart: always\n    hostname: zoo2\n    ports:\n      - 2182:2181\n    environment:\n      ZOO_MY_ID: 2\n      ZOO_SERVERS: server.1=zoo1:2888:3888 server.2=0.0.0.0:2888:3888 server.3=zoo3:2888:3888\n\n  zoo3:\n    image: zookeeper\n    restart: always\n    hostname: zoo3\n    ports:\n      - 2183:2181\n    environment:\n      ZOO_MY_ID: 3\n      ZOO_SERVERS: server.1=zoo1:2888:3888 server.2=zoo2:2888:3888 server.3=0.0.0.0:2888:3888\n~~~\n## 安装zk客户端管理工具\n[zkdash](https://github.com/ireaderlab/zkdash.git)\n## zk基本命令\n1. 启动ZK服务: bin/zkServer.sh start\n2. 查看ZK服务状态: bin/zkServer.sh status\n3. 停止ZK服务: bin/zkServer.sh stop\n4. 重启ZK服务: bin/zkServer.sh restart \n5. 连接服务器: zkCli.sh -server 127.0.0.1:2181\n6. ls [path]\n7. create [path] [value]\n8. get/set [path] [value]\n9. quit\n10.help\n\n## zk示例代码\n[php demo](https://github.com/php-zookeeper/php-zookeeper/blob/master/examples/Zookeeper_Example.php)\n\nwatch功能可能需要非安全线程版本的php\nhttps://www.imooc.com/article/31703","tags":["zookeeper,docker"]},{"title":"etcd实践","url":"%2F2019%2F04%2F10%2Fetcd%E5%AE%9E%E8%B7%B5%2F","content":"cat << EOF | tee server-csr.json\n{\n    \"CN\": \"etcd\",\n    \"hosts\": [\n    \"10.186.32.12\",\n    \"10.186.26.40\",\n    \"10.104.247.233\"\n    ],\n    \"key\": {\n        \"algo\": \"rsa\",\n        \"size\": 2048\n    },\n    \"names\": [\n        {\n            \"C\": \"CN\",\n            \"L\": \"CS\",\n            \"ST\": \"CS\"\n        }\n    ]\n}\nEOF\n\ncd /usr/local/src\ntar zxvf etcd-v3.2.28-linux-amd64.tar.gz\ncd etcd-v3.2.28-linux-amd64\ncp etcd etcdctl /opt/etcd/bin/\n\ncat << EOF | tee /opt/etcd/cfg/etcd.conf\n#[Member]\nETCD_NAME=\"etcd01\"\nETCD_DATA_DIR=\"/var/lib/etcd/default.etcd\"\nETCD_LISTEN_PEER_URLS=\"https://10.186.26.40:2380\"\nETCD_LISTEN_CLIENT_URLS=\"https://10.186.26.40:2379,http://127.0.0.1:2379\"\n\n#[Clustering]\nETCD_INITIAL_ADVERTISE_PEER_URLS=\"https://10.186.26.40:2380\"\nETCD_ADVERTISE_CLIENT_URLS=\"https://10.186.26.40:2379\"\nETCD_INITIAL_CLUSTER=\"etcd01=https://10.186.26.40:2380,etcd02=https://10.186.32.12:2380,etcd03=https://10.104.247.233:2380\"\nETCD_INITIAL_CLUSTER_TOKEN=\"etcd-cluster\"\nETCD_INITIAL_CLUSTER_STATE=\"new\"\n\n#[Security]\nETCD_CERT_FILE=\"/opt/etcd/ssl/server.pem\"\nETCD_KEY_FILE=\"/opt/etcd/ssl/server-key.pem\"\nETCD_TRUSTED_CA_FILE=\"/opt/etcd/ssl/ca.pem\"\nETCD_CLIENT_CERT_AUTH=\"true\"\nETCD_PEER_CERT_FILE=\"/opt/etcd/ssl/server.pem\"\nETCD_PEER_KEY_FILE=\"/opt/etcd/ssl/server-key.pem\"\nETCD_PEER_TRUSTED_CA_FILE=\"/opt/etcd/ssl/ca.pem\"\nETCD_PEER_CLIENT_CERT_AUTH=\"true\"\nEOF\n\ncat << EOF | tee /opt/etcd/cfg/etcd.conf\n#[Member]\nETCD_NAME=\"etcd02\"\nETCD_DATA_DIR=\"/var/lib/etcd/default.etcd\"\nETCD_LISTEN_PEER_URLS=\"https://10.186.32.12:2380\"\nETCD_LISTEN_CLIENT_URLS=\"https://10.186.32.12:2379,http://127.0.0.1:2379\"\n\n#[Clustering]\nETCD_INITIAL_ADVERTISE_PEER_URLS=\"https://10.186.32.12:2380\"\nETCD_ADVERTISE_CLIENT_URLS=\"https://10.186.32.12:2379\"\nETCD_INITIAL_CLUSTER=\"etcd01=https://10.186.26.40:2380,etcd02=https://10.186.32.12:2380,etcd03=https://10.104.247.233:2380\"\nETCD_INITIAL_CLUSTER_TOKEN=\"etcd-cluster\"\nETCD_INITIAL_CLUSTER_STATE=\"new\"\n\n#[Security]\nETCD_CERT_FILE=\"/opt/etcd/ssl/server.pem\"\nETCD_KEY_FILE=\"/opt/etcd/ssl/server-key.pem\"\nETCD_TRUSTED_CA_FILE=\"/opt/etcd/ssl/ca.pem\"\nETCD_CLIENT_CERT_AUTH=\"true\"\nETCD_PEER_CERT_FILE=\"/opt/etcd/ssl/server.pem\"\nETCD_PEER_KEY_FILE=\"/opt/etcd/ssl/server-key.pem\"\nETCD_PEER_TRUSTED_CA_FILE=\"/opt/etcd/ssl/ca.pem\"\nETCD_PEER_CLIENT_CERT_AUTH=\"true\"\nEOF\n\ncat << EOF | tee /opt/etcd/cfg/etcd.conf\n#[Member]\nETCD_NAME=\"etcd03\"\nETCD_DATA_DIR=\"/var/lib/etcd/default.etcd\"\nETCD_LISTEN_PEER_URLS=\"https://10.104.247.233:2380\"\nETCD_LISTEN_CLIENT_URLS=\"https://10.104.247.233:2379,http://127.0.0.1:2379\"\n\n#[Clustering]\nETCD_INITIAL_ADVERTISE_PEER_URLS=\"https://10.104.247.233:2380\"\nETCD_ADVERTISE_CLIENT_URLS=\"https://10.104.247.233:2379\"\nETCD_INITIAL_CLUSTER=\"etcd01=https://10.186.26.40:2380,etcd02=https://10.186.32.12:2380,etcd03=https://10.104.247.233:2380\"\nETCD_INITIAL_CLUSTER_TOKEN=\"etcd-cluster\"\nETCD_INITIAL_CLUSTER_STATE=\"new\"\n\n#[Security]\nETCD_CERT_FILE=\"/opt/etcd/ssl/server.pem\"\nETCD_KEY_FILE=\"/opt/etcd/ssl/server-key.pem\"\nETCD_TRUSTED_CA_FILE=\"/opt/etcd/ssl/ca.pem\"\nETCD_CLIENT_CERT_AUTH=\"true\"\nETCD_PEER_CERT_FILE=\"/opt/etcd/ssl/server.pem\"\nETCD_PEER_KEY_FILE=\"/opt/etcd/ssl/server-key.pem\"\nETCD_PEER_TRUSTED_CA_FILE=\"/opt/etcd/ssl/ca.pem\"\nETCD_PEER_CLIENT_CERT_AUTH=\"true\"\nEOF","tags":["etcd"]},{"title":"K8S的日志分析与监控ingress","url":"%2F2019%2F04%2F10%2FK8S%E7%9A%84%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E4%B8%8E%E7%9B%91%E6%8E%A7ingress%2F"},{"title":"linux下配置代理访问谷歌","url":"%2F2019%2F04%2F09%2Flinux%E4%B8%8B%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86%E8%AE%BF%E9%97%AE%E8%B0%B7%E6%AD%8C%2F","content":"> 背景\n\n最近在实践K8S，因为很多地方需要访问谷歌，又不想设置阿里镜像，也不想用在node中pull国内镜像再打tag，所以就想利用手里有的香港服务器作为代理使用。\n\n在MAC上和Linux上分别测试通过，特此记录一下，方便以后用于服务器curl get墙外资源或者docker等资源\n环境：mac 10.14 centos7.2\n\n> 思路\n\n利用本地的SSR客户端，连接远程SS服务之后，此时的代理客户端会有一个socket5协议的代理，但是很多时候需要转变为http代理，可以利用privoxy之类的方案转化\n\n> MAC\n\n一般安装有SSX_NG作为SSR的客户端管理。\n\n在菜单http代理设置中可以设置ip为0.0.0.0，port为1087，这个port是你在设置后面http代理是用到的。\n~~~\nexport http_proxy=http://127.0.0.1:1087\nexport https_proxy=http://127.0.0.1:1087\nexport no_proxy=localhost\n\n之后可以用于kubenetes的安装镜像和k8s\n比如：\nminikube start --docker-env http_proxy=http://192.168.99.104:1087 --docker-env https_proxy=http://192.168.99.104:1087 --docker-env no_proxy=localhost,127.0.0.1,192.168.99.0/24 --log_dir=tmp \n~~~\n> CENTOS 7\n\n~~~\n1、安装SSR\n方案一、\nit clone https://github.com/SAMZONG/gfwlist2privoxy.git\ncd gfwlist2privoxy/\nmv ssr /usr/local/bin\nchmod +x /usr/local/bin/ssr\n\nssr install\n\nssr config #配置文件路径 /usr/local/share/shadowsocksr/config.json\n\nssr start\nssr stop\nssr uninstall # 这里操作会删除/usr/local/share/shadowsocksr\n~~~\n\n方案二、\n安装electron_ssr\ngit clone https://github.com/erguotou520/electron-ssr.git\n\n不详述，两个快捷键，如果有gnome界面的话，ctrl+shift+W显示隐藏界面，ctrl+shift+B显示隐藏菜单\n\n显示菜单打开配置文件，这个直接带有http_proxy，看配置文件中的httProxyPort是什么，以后系统配置环境变量也要用这个\n配置文件中的pacPort，一般用于代理为PAC模式。然后在网络设置中可以设置。也可以和上面一样export 设置环境变量。\n\n其他设置与操作同MAC系统\n\n\n\n\n\n\n\n","tags":["linux,ssr,proxy"]},{"title":"php 实时输出运行结果","url":"%2F2019%2F04%2F02%2Fphp-%E5%AE%9E%E6%97%B6%E8%BE%93%E5%87%BA%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%2F","content":"~~~\nset_time_limit(0);\nob_end_clean();\nob_implicit_flush();\nheader('X-Accel-Buffering: no'); // 关键是加了这一行。\necho \"something@@\";\n~~~","tags":["PHP"]},{"title":"hexo 常用命令","url":"%2F2019%2F04%2F02%2Fhexo-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F","content":"[更多参考](https://hexo.io/docs)\n> 安装\n~~~\nnpm install -g hexo\nnpm update -g hexo\nhexo init \n~~~\n> 常用\n~~~\nhexo n == hexo new \"a new post\"  新建文章，最好用双引号括起来\n\nhexo g == hexo generate     生成静态文件到public文件夹\n\nhexo s == hexo server    Server at localhost:4000，根目录为public\n\nhexo d == hexo deploy   部署到远程服务里，例如github\n\nhexo p == hexo publish  新建草稿draft\n\nhexo clean     清除缓存文件\n\nhexo new page \"about\"   生成 /source/about/index.md 文件\n~~~\n> 后端\n~~~\nhexo server    默认为动态监听\n\nhexo server -s   静态模式\n\nhexo server -p 5000  指定端口\n\nhexo server -i 10.20.62.123   指定IP\n~~~\n> 文章摘要\n~~~\n方式1：在front-matter中编写\n\ndescription: \"This a digest bla bla...\" \n\n方式2\n\n在文章中插入一行  <!--more-->  以上部分为摘要\n~~~\n> 添加sitemap\n~~~\nnpm install hexo-generator-sitemap --save\n\n_config.yml\n\nsitemap:\n    path: sitemap.xml\n~~~\n> 更多\nhttps://hexo.io/zh-cn/docs/","tags":["hexo"]},{"title":"Kubernates之旅-环境篇","url":"%2F2019%2F04%2F02%2FKubernates%E4%B9%8B%E6%97%85-%E7%8E%AF%E5%A2%83%E7%AF%87%2F","content":"> 平台\n* centos 7.2\n\n> 安装内核\n\n> 安装virtualBox\n\n~~~\nwget -q https://www.virtualbox.org/download/oracle_vbox.asc -O- | rpm --import -\n\nwget https://download.virtualbox.org/virtualbox/6.0.4/VirtualBox-6.0-6.0.4_128413_el7-1.x86_64.rpm\n\nrpm -ivh VirtualBox-6.0-6.0.4_128413_el7-1.x86_64.rpm\n~~~\n\n> 安装kubectl\n\n~~~\ncurl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl\n\nchmod +x ./kubectl\n\nmv ./kubectl /usr/local/bin/kubectl\n~~~\n\n> 安装minikube\n\n~~~\ncurl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-darwin-amd64 \\\n && chmod +x minikube\nmv minikube /usr/local/bin\n~~~\n> 设置代理安装单节点集群\n~~~\n#将本地SSR开启http代理，设置IP：0.0.0.0\n#参考：https://www.jianshu.com/p/48804c8bb250\n\nexport http_proxy=http://127.0.0.1:1087;export https_proxy=http://127.0.0.1:1087;\nexport no_proxy=192.168.99.0/24\n\nminikube start --docker-env http_proxy=http://192.168.99.1:1087 --docker-env https_proxy=http://192.168.99.1:1087 --docker-env no_proxy=localhost,127.0.0.1,192.168.99.0/24 --log_dir=tmp \n#linux代理参考：https://samzong.me/2017/11/17/howto-use-ssr-on-linux-terminal/\n#mac安装参考https://github.com/Unknwon/wuwen.org/issues/20\n~~~\n> 新建pod\n\n~~~\ngit clone https://github.com/acinwinstack/k8s-concept-demo.git\n\ncd k8s-concept-demo\n\nkubectl apply -f pod.yml\nkubectl apply -f service.yml\n\nkubectl cluster-info\nkubectl get svc\n\npod 设定用什么镜像构建容器，容器端口是什么，但还是不提供服务\nservice 根据selector参数判断为哪个pod提供服务，对外提供什么端口，复制多少份提供服务，节点类型是什么？如果是NodePort就一般是3万以上的端口\n节点类型还有clusterIP【用于minion节点中容器与容器，pod与pod，或者container与pod之间通信】，loadbalancer【对外部loadbalance提供】\n\n外部访问就根据集群的ip+service暴露的端口访问\n~~~\n> deployment pod svc区别\n\n> yaml文档注释\nCNI 做的事情就是管理container，pod，service，host之间的通信，转发等相关工作\n怎么做呢，可以在一份部署的yaml文档中看到\n看一份k8s的service 部署文档,因为向外暴露的是service\n~~~\napiVersion: v1\nkind: Service\nmetadata:\n  name: nginx-svc\nspec:\n  ports:\n  - port: 80\n    name: http\n    targetPort: 80\n    protocol: TCP\n  selector:\n    app: concept-terms\n  type: NodePort\n~~~\n参考pod 文档\n~~~\napiVersion: v1\nkind: Pod\nmetadata:\n  name: nginx\n  labels:\n    app: concept-terms\nspec:\n  containers:\n  - name: web\n    image: nginx\n    ports:\n    - containerPort: 80\n~~~\n\nservice 中的port会根据selector去查找节点中的pod里labels项含有相同值的，然后在把port对应上target port，type有四种，nodeport会随机给一个30000以上的端口\n\ncluster ip\n    \n    pod 与pod之间的通信\n\n对外提供服务\nloadbalance\nnoddeport\n\n\n![kubernets网络通信](https://spark-1300032833.cos.ap-guangzhou.myqcloud.com/blog/2019-11-21-v1zvma.png)","tags":["kubernates,k8s,VirtualBox,minicube"]},{"url":"%2F2018%2F12%2F28%2F%E5%88%86%E5%B8%83%E5%BC%8FID%E5%AE%9E%E8%B7%B5%2F","content":"## 分布式ID特点\n\n* 递增趋势\n* 唯一\n* 最好自带时间属性\n\n    分布式id唯一性好理解，但如果只有唯一性，那么有些需要用到排序的时候，就还需要新建一个时间字段的普通索引。效率会下降，那么如果id能自带时间属性，递增的趋势，同时又唯一呢？只要建立一个id字段的聚集索引就行。\n\n    方案很多，记录一下php端的snowflake算法\n\n    纯PHP无法实现SnowFlake算法，因为线程安全版本(需要tid)和非线程安全版本(需要pid)不能生成相同格式的id(本项目的tid是系统中唯一的所以不用担心多个进程中tid冲突)，不能生成相同格式就不方便查询，并且PHP作为脚本语言无法维护sequence，当脚本结束的时候sequence又要被初始化，所以在大并发情况纯PHP实现的版本SnowFlake算法根本没有什么作用。所以就诞生了这个项目，以下为线程安全版本和非线程安全版本差别。\n\n    [github](https://github.com/Sxdd/php_snowflake)"},{"title":"mycat旧项目改造","url":"%2F2018%2F12%2F20%2Fmycat%E6%97%A7%E9%A1%B9%E7%9B%AE%E6%94%B9%E9%80%A01%2F","content":"# mycat对一个就项目数据库的改造\n## 背景\n一个项目的单表数据达到700W，考虑到日增长在2W左右，需要考虑分片，经过调研，为了系统解耦，决定采用引入中间件mycat的方案\n\n## 实践\n### 搭建实验环境\nmycat service: 10.10.10.245\n\nmysql: 10.10.10.10 & 10.10.10.9\n~~~\n1、mycat \nwget http://dl.mycat.io/1.6.6.1/Mycat-server-1.6.6.1-release-20181031195535-linux.tar.gz\n\ntar zxvf Mycat-server-1.6.6.1-release-20181031195535-linux.tar.gz\nmv Mycat... /usr/local/mycat\n\n2、mysql\n10.10.10.10为主库\n10.10.10.9为从库\n\n2.1、先在主库上操作\ndocker pull mysql:5.7\n\nmkdir -p /data/docker/mysql/3306\n\nvi mysqld.cnf\n\n[mysqld]\ngtid_mode=on\nenforce_gtid_consistency=on\nlog-bin=mysql-bin\nserver-id=1\nreplicate-ignore-db=mysql\nlog_slave_updates=1\nlower_case_table_names=1\n\ndocker run --name mlink-mysql -v /data/docker/mysql/3306:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=mlink7749 -e MYSQL_DATABASE=mlink -p 3306:3306 -d mysql:5.7\n\ndocker exec -it mlink-mysql /bin/bash\n\nmysql -uroot -pmlink7749\n\nCREATE USER 'repl'@'%' IDENTIFIED BY 'mlink7749';\n\nGRANT REPLICATION SLAVE ON *.* TO 'repl'@'%'; \nflush privileges; \n\n2.2、再在主库上操作\ndocker pull mysql:5.7\n\nmkdir -p /data/docker/mysql/3306\n\nvi mysqld.cnf\n\n[mysqld]\ngtid_mode=on\nenforce_gtid_consistency=on\nlog-bin=mysql-bin\nserver-id=2\nreplicate-ignore-db=mysql\nlog_slave_updates=1\nlower_case_table_names=1\n\ndocker run --name mlink-mysql -v /data/docker/mysql/3306:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=mlink7749 -e MYSQL_DATABASE=mlink -p 3306:3306 -d mysql:5.7\n\ndocker exec -it mlink-mysql /bin/bash\n\nmysql -uroot -pmlink7749\n\nCHANGE MASTER TO \n　　　MASTER_HOST = '10.10.10.10', \n　　　MASTER_PORT = 3308, \n　　　MASTER_USER = 'repl', \n　　　MASTER_PASSWORD = 'mlink7749', \n　　　MASTER_AUTO_POSITION = 1;\n\nstart slave;\n~~~\n## 配置mycat\n### 在mycat server上操作\n~~~ bash\ncd /usr/local/mycat/conf/\n\nvi server.xml\n\n<user name=\"root\" defaultAccount=\"true\">\n\t\t<property name=\"password\">mlink7749</property>\n\t\t<property name=\"schemas\">MLINKDB</property>\n</user>\n\n vi schema.xml\n\n<?xml version=\"1.0\"?>\n<!DOCTYPE mycat:schema SYSTEM \"schema.dtd\">\n<mycat:schema xmlns:mycat=\"http://io.mycat/\">\n\t<schema name=\"MLINKDB\" checkSQLschema=\"false\" sqlMaxLimit=\"100\" dataNode=\"dn0\">\n\t\t<table name=\"mlink_log_visitor\" dataNode=\"dn1,dn2,dn3,dn4\" rule=\"auto-sharding-long\" />\n\t</schema>\n\t<dataNode name=\"dn0\" dataHost=\"localhost\" database=\"mlink\" />\n\t<dataNode name=\"dn1\" dataHost=\"localhost1\" database=\"mlink_visitor1\" />\n\t<dataNode name=\"dn2\" dataHost=\"localhost1\" database=\"mlink_visitor2\" />\n\t<dataNode name=\"dn3\" dataHost=\"localhost1\" database=\"mlink_visitor3\" />\n\t<dataNode name=\"dn4\" dataHost=\"localhost1\" database=\"mlink_visitor4\" />\n\t<dataHost name=\"localhost1\" maxCon=\"100000\" minCon=\"10\" balance=\"0\" writeType=\"0\" dbType=\"mysql\" dbDriver=\"native\" switchType=\"1\"  slaveThreshold=\"100\">\n\t\t<heartbeat>select 1</heartbeat>\n\t\t<writeHost host=\"hostM1\" url=\"10.10.10.10:3306\" user=\"root\" password=\"mlink7749\">\n\t\t</writeHost>\n\t</dataHost>\n\t<dataHost name=\"localhost\" maxCon=\"100000\" minCon=\"10\" balance=\"0\" writeType=\"0\" dbType=\"mysql\" dbDriver=\"native\" switchType=\"1\"  slaveThreshold=\"100\">\n\t\t<heartbeat>select 1</heartbeat>\n\t\t<writeHost host=\"hostM2\" url=\"10.10.10.9:3306\" user=\"mlink\" password=\"MmcQCpbHiM\">\n\t\t</writeHost>\n\t</dataHost>\n</mycat:schema>\n~~~\n使用mycat需要清楚的几个问题：\n\n* 如何分片利于扩展和查询\n* 插入的全局分布式ID方案\n* 高可用设计\n* 分页问题\n* join\n\nvisitor表是用于记载用户访问日志的表，\n有鲜明的时间分区性质，也有冷热数据分区性质\n\n\n\n\n\n","tags":["mysql"],"categories":["db"]}]